<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="计算机网络和因特网">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="STERIA LAB">
<meta property="og:description" content="计算机网络和因特网">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211103225041616.png">
<meta property="article:published_time" content="2021-09-09T13:52:36.000Z">
<meta property="article:modified_time" content="2021-12-16T13:17:21.794Z">
<meta property="article:author" content="STEVE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211103225041616.png">

<link rel="canonical" href="http://example.com/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络 | STERIA LAB</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">STERIA LAB</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">for my study life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="STEVE">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STERIA LAB">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">

            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-09 21:52:36" itemprop="dateCreated datePublished" datetime="2021-09-09T21:52:36+08:00">2021-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-16 21:17:21" itemprop="dateModified" datetime="2021-12-16T21:17:21+08:00">2021-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/reading-notes/" itemprop="url" rel="index"><span itemprop="name">reading notes</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/reading-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h2><span id="more"></span>

<h3 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h3><p>因特网和网络协议的总体概述</p>
<ul>
<li>构成因特网的基本硬件和软件组件</li>
<li>分布式应用提供服务的联网基础设施</li>
</ul>
<p>计算机网络：多台计算机，数据通信，资源共享，通过通信线路,通信设备,协议互联</p>
<h4 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h4><ul>
<li><strong>主机</strong>,<strong>端系统</strong>：各种传统和非传统的连接到互联网的设备</li>
<li>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起,不同的链路能够以不同的速率传输数据,链路的<strong>传输速率</strong>以比特每秒<code>bit/s</code>度量,当一台端系统向另一台端系统发送数据的时候,发送端系统将数据分段,并为每段加上首部字节,由此形成的信息包称为<strong>分组</strong>,分组通过网络发送到目的端系统,在那里被装配成初始数据</li>
<li>分组交换机从它的一条入通信链路接收到达的分组,并从它的一条出通信链路转发该分组.当下两个最著名的分组交换机<strong>路由器</strong>,<strong>链路层交换机</strong>这两种类型交换机向最终目的地转发分组,链路层交换机通常用于接入让中,路由器通常用于网络核心中.从发送端系统到接收端系统,一个分组所经历的一系列通信链路和分组交换机称为通过给网络的路径(route/path)</li>
<li>端系统通过**因特网服务提供商(Internet Service Provider,ISP),接入互联网,为端系统提供接入的ISP也必须互联,较低层的ISP通过国家的,国际的叫高层的ISP互联,运行IP协议,遵从一定的命名和地址规则</li>
<li>端系统,分组交换机以及其他因特网部件都要运行一系列<strong>协议(protocal)</strong>:<strong>TCP(Transmission Control Protocol,传输控制协议)</strong>,**IP(Internet Protocol, 网络协议)**是因特网中最重要的两个协议,IP协议定义了在路由器和端系统这件发送和接收的分组格式.因特网的主要协议统称为TCP/IP协议</li>
<li>**因特网标准(internet standard)由因特网工程任务组(Internet Engineering Task Force,IETF)研发,IETF的标准文档为请求评论(Request For Comment, RFC),RFC定义了TCP,IP,HTTP,SMTP等协议</li>
</ul>
<h4 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h4><p>从为应用程序提供服务的基础设施的角度来描述英特网</p>
<ul>
<li><strong>分布式应用程序</strong>:涉及多个互相交换数据的端系统.因特网应用程序运行在端系统上,并不运行在网络核心中的分组交换机中,尽管分组交换机能够加速端系统之间的数据交换,但是它们并不在意作为数据的源或宿的应用程序</li>
<li>运行在一个端系统上的应用程序怎样令因特网向运行在另一个端系统上的段间发送数据?与因特网相连的端系统提供一个<strong>套接字接口(socket interface)</strong>,该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地的程序交互数据的方式</li>
</ul>
<h4 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h4><ul>
<li>网络协议:在因特网中设计两个或多个远程通信实体的所有活动都收到协议的制约</li>
</ul>
<blockquote>
<p>协议(protocol)定义了在两个或多个通信实体之间交换的报文的格式和顺序,以及报文发送和/或接收一条报文或其他事件所采取的动作</p>
</blockquote>
<h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><ul>
<li>端系统也称为<strong>主机</strong>,因为它们容纳(运行)应用程序,主机有时候又被进一步划分为两类<strong>客户(client)<strong>和</strong>服务器(server)</strong>,当下大部分提供搜索结果,电子邮件,web页面,视频的服务器都属于大型<strong>数据中心</strong></li>
</ul>
<h4 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h4><p><strong>接入网</strong>:将端系统物理连接到其**边缘路由器(edge router)的网络</p>
<ol>
<li>家庭接入:DSL,电缆,FTTH,拨号和卫星<ul>
<li>当下,宽带住宅接入有两种最流行的类型:<strong>数字用户线(digital Subscriber Line, DSL)和电缆</strong>.用户通常从提供本地电话接入的本地电话公司处获得DSL的因特网接入,因此当使用DSL时,用户的本地电话公司也是它的ISP,每个用户DSL调制解调器使用现有的电话线(双铜绞线)与位于电话公司的本地中心局(CO)中的数字用户线接入复用器(DSLAM)交换数据,家庭的DSL调制解调器得到数字数据后将其转换为高频音,以通过电话先传输给本地中心局<ul>
<li>现有电话线:<ul>
<li>0-4kHz:普通的双向电话通道</li>
<li>4-50kHz:中速上行信道</li>
<li>50kHz-1mHz:高速下行信道</li>
</ul>
</li>
<li>这种方法使单根DSL线路看起来就像有3根单独的电路一样,因此一个电话呼叫和一个因特网连接能够同时共享DSL链路(频分复用技术),在本地中心局,DSLAM把数据和电话信号分隔开,DSL标准定义了多个传输速率:12Mbps下行和1.8Mbps上行传输速率[ITU 1999],以及55Mbps下行和15Mbps上行传输速率[ITU 2006],这种接入是不对称的</li>
</ul>
</li>
<li>DSL利用电话公司现有的本地电话基础设施,**电缆因特网接入(cable Internet access)**利用了有线电视公司现有的有线电视基础设施,因为在这个系统中用到了光纤和同轴电缆,因此它经常被称为混合光纤同轴(Hybird Fiber Coax, HFC)系统</li>
<li>电缆因特网接入需要特殊的调制解调器,称为电缆调制解调器(cable modem),通过一个以太网端口连接到家庭PC.电缆调制解调器端接收系统(Cable Modem Termination system)将HFC网络划分为上行和下行两个信道,且接入通常不对称</li>
<li>电缆因特网接入的一个重要特征是共享广播媒体,特别是,由头端发送的每个分组向下经每段链路到每个家庭,每个家庭发送的每个分组经上行通道向头端传输,如果多人同时使用,实际速率会大大减少,反之,每个用户都可以以几乎全部的下行速率接收web网页,同时,我们需要一个分布式多路访问协议来协调传输和避免碰撞</li>
<li><strong>光纤到户(Fiber To The Home, FTTH)</strong>,从本地中心局直接到家庭提供了一条光纤路径</li>
<li>光纤分布方案:<ul>
<li>直接光纤:最简单的光纤分布网络,从本地中心局到每户设置一根光纤</li>
<li>从中心局出来的每根光纤由许多家庭共享,知道相对接近这些家庭的位置,该光纤才分成每户一根光纤,这种分配由两种有竞争行的光纤分布体系结构:<ul>
<li>有源光纤结构(Active Optical Network,AON),本质上就是交换以太网</li>
<li>无源光纤结构(Passive Optical Network,PON):每个家庭具有一个光纤网络接收器(Optical Network Terminator, ONT),由专门的光纤连接到附近的分配器(splitter),该分配器把一些家庭(通常少于100个)集结到一根共享的光纤,该光纤再连接到本地电话和公司的中心局中的光纤线路端接器(Optical Line Terminator,OLT).在家庭中,用户将一台家庭路由器,通常是无线路由器与ONT相连并经过这台家庭路由器接入因特网,在PON体系结构中,所有从OLT发送到分配器的分组在分配器(类似一个电缆头端)处复制</li>
</ul>
</li>
</ul>
</li>
<li>FTTH有潜力提供每秒千兆比特范围的因特网接入速率</li>
<li>还有两种接入网技术:在无法提供DSL,电缆和FTTH的地方,能够使用卫星链路将住宅以找过1Mbps的速率与因特网相连;使用传统电话线的拨号接入,这个和DSL基于相同的模式:家庭的调制解调器通过电话线连接到ISP的调制解调器</li>
</ul>
</li>
<li>企业(和家庭)接入:以太网和WIFI*<ul>
<li>在公司和大学校园以及越来越多的家庭环境中,使用局域网(LAN)将端系统连接到边缘路由器,以太网是目前位置公司,大学和家庭网络中最流行的接入技术</li>
<li>无线LAN环境中,无线用户从/到一个接入点发送/接收分组,该接入点与企业网连接,企业网再与有线因特网相连</li>
<li>当下许多家庭将宽带住宅接入(即电缆调制解调器或DSL)与廉价的无线局域网技术结合起来,产生强大的家用网络</li>
</ul>
</li>
<li>广域无限接入:3G和LTE<ul>
<li>应用蜂窝网提供商运营的基站来发送和接收分组,</li>
<li>LTS(Long-Term Evolution)长期演进,</li>
</ul>
</li>
</ol>
<h4 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h4><p>简要概述一些常在因特网中使用的传输媒体</p>
<ul>
<li>在比特被传输的历程中,从源到目的地传输的时候,通过一些列”发射器”-“接收器”对,跨越一种<strong>物理媒体</strong>传播电子波或光脉冲来发射比特</li>
<li>物理媒体包括:双铜绞线,多模光纤缆,陆地无线电频谱和卫星无线电谱,分为两类:<strong>导引型媒体</strong>和<strong>非导引型媒体</strong><ul>
<li>导引型媒体:电波沿固体媒体前行:光缆,双绞铜线,同轴电缆</li>
<li>非导引型媒体:无限局域网,数字卫星频道</li>
</ul>
</li>
<li>成本问题:物理链路(铜线光缆等)实际成本与其他网络成本比是相当小的,</li>
</ul>
<ol>
<li>双绞铜线<ul>
<li>最便宜且最常用的导引型传输媒体,两根绝缘的铜线绞合后减少附件类似的双绞线的电气干扰</li>
<li>无屏蔽双绞线(Unshielded Twisted Pair, UTP)用于建筑物内的计算机网络中,即用于局域网中</li>
<li>速率:10Mbps-10Gbps</li>
</ul>
</li>
<li>同轴电缆<ul>
<li>类似于双绞铜线,但是同轴电缆是同心而不是并行的</li>
<li>在电缆电视系统中十分普遍</li>
<li>能被用作导引型<strong>共享媒体</strong>,许多端系统能够直接与该电缆相连,每个端系统都能接收由其他端系统发送的内容</li>
<li>速率:数十Mbps</li>
</ul>
</li>
<li>光纤<ul>
<li>不受电磁干扰,很难窃听</li>
<li>长途导引型传输媒体</li>
<li>速率:数十甚至数百Gbps</li>
</ul>
</li>
<li>陆地无线电信道<ul>
<li>无线电信道承载电磁频谱中的信号,不需要安装物理线路,并具有穿透墙壁,提供与移动用户的连接</li>
<li>依赖于传播环境和信号传输的距离,环境上的考虑取决于路径损耗和遮挡衰落以及干扰</li>
<li>大致划分三类<ul>
<li>运行在很短距离(1m-2m), 无线头戴式耳机,键盘和医疗设备</li>
<li>运行在局域,跨越数十到几百米, 无线LAN技术</li>
<li>运行在广域,跨越数万米,蜂窝网接入技术</li>
</ul>
</li>
</ul>
</li>
<li>卫星无线电信道<ul>
<li>一颗通信卫星连接地球上的两个或多个微波发射器/接收器,被称为地面站</li>
<li>卫星在一个频段上接收传输,使用一个转发器再生信号,并在另一个频率上发射信号</li>
<li>两类卫星:<ul>
<li>同步卫星(geostationary satellite),同步卫星永久的停留在地球上方的相同点上,通过将卫星置于地球表面上方36000的轨道上取得这种静止性,能够以数百Mbps速率运行的卫星链路通常宇通那些无法使用DSL或电缆因特网接入的区域</li>
<li>近地轨道(Low-Earth Orbiting, LEO),非常靠近地球,不是永久的停留在地球上方的一个点,围绕着地球旋转,且彼此之间可以相互通信,也可以与地面站通信</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><ul>
<li>在各种网络应用中,端系统彼此交换<strong>报文(message)</strong>,报文能够包含协议设计者需要的任何东西,可以执行一种控制功能,也可以包含数据</li>
<li>为了从源端系统向目的端系统发送一个报文,源将长报文划分为较小的数据块,称为<strong>分组(packet)</strong></li>
<li>在源和目的地之间,每个分组都通过通信链路和**分组交换机(packet switch)**传送,交换机主要有两类:<strong>路由器(router)<strong>和</strong>链路层交换机(link-layer switch)</strong></li>
<li>发送一个L比特的分组,传输速率为R比特/秒,传输该分组的时间是L/R秒,分组以等于该链路最大传输速率的速度传输通过通信链路</li>
</ul>
<ol>
<li>存储转发传输<ul>
<li>多数分组交换机在链路的输入端使用**存储转发传输(store-and-forward transmission)**机制,让交换机能够在开始向输出链路传输该分组的第一个比特之前必须接收到整个分组</li>
<li>分组的前沿到达路由器以后,路由器不能传输已经接收的比特,必须先缓存该分组的比特,当该路由器接收完了该分组的所有比特以后才能开始向出链路传输</li>
</ul>
</li>
<li>排队时延和分组丢失<ul>
<li>每台分组交换机有多条链路与其相连,对于每条相连的链路,该分组交换机有一个<strong>输出缓存(output buffer,也称为输出队列(output queue))</strong>,用于存储路由器准备发往的那个链路的分组,如果到达的分组需要传输到某条链路,却发现该链路正在传输其他分组,就需要在输出缓存中等待</li>
<li>因此,除了转发时延以外,分组还有输出缓存的<strong>排队时延</strong>,这些时延是有变化的,变化的程度取决于网络的拥塞程度,因为缓存空间的大小有限,当到达的分组发现该缓存已经被其他等待传输的分组完全充满了,这种情况下,将出现<strong>丢包</strong></li>
</ul>
</li>
<li>转发表和路由选择协议<ul>
<li>在因特网中,每个端系统具有一个称为IP地址的地址,当源主机向目的端系统发送一个分组的时候,源在该分组的首部包含了目的地和IP地址.当一个分组到达网络中的路由器时,路由器检查该分组目的地址的一部分,并向一台相邻路由器转发该分组,更特别的是,每台路由器具有一个<strong>转发表(forwarding table)</strong>,用于将目的地址映射称为输出链路</li>
<li>因特网具有一些特殊的<strong>路由选择协议(routing protocol)</strong>,用于自动地设置这些转发表</li>
</ul>
</li>
</ol>
<h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>通过网络链路和交换机移动数据有两种基本方法:<strong>电路交换(circuit switching)<strong>和</strong>分组交换(pachet switching)</strong></p>
<ul>
<li>在电路交换网络中,在端系统间通信会话期间,预留了端系统间沿路径通信所需要的资源(缓存,链路传输速率)</li>
<li>在分组交换网络中,这些资源是不会预留的</li>
</ul>
<p>传统的电话网络就是电路交换网络的例子,再发送方能够发送信息之前,该网络必须再发送方和接受方之间建立一条连接,此时沿着发送方和接受方之间路径上的交换机都将为该连接维护连接状态,该连接被称为一条电路(circuit),当网络创建这种电路时,它也在连接期间在该网络链路上预留了恒定的传输速率,能够以确保的恒定速率向接收方传送数据</p>
<p>但是在一些分组交换网中(如因特网),两台主机之间没有专用的<strong>端对端连接</strong>,分组被发往网络里也不会预留链路资源,如果此时其他分组也需要经过该链路进行传输,使得链路之一出现拥塞,则会产生时延</p>
<ol>
<li>电路交换网络中的复用</li>
</ol>
<p>链路中的电路通过**频分复用(frequency-Division Multiplexing, FDM)<strong>或</strong>时分复用(Time-Dicision Multiplexing, TDM)**来实现的,对于FDM,链路的频谱由跨越链路穿凿的所有连接共享,特别是,在连接期间,链接为每条连接专用一个频段</p>
<ul>
<li>在电话网路中,这个评断的宽度通常为4kHz,该频段的宽度称为<strong>带宽(band-width)</strong></li>
<li>调频无线电台也是用FDM来共享88MHz~108MHz的频谱,其中每个电台被分配一个特定的频段</li>
</ul>
<p>对于一条TDM链路,时间被划分成固定期间的帧,并且每个帧又被划分为固定数量的时隙,当网络跨越一条链路创建一条连接的时候,网络在每个帧中为该连接指定一个时隙.这些时隙专门由该连接单独使用,一个时隙(在每个帧内)可用于传输该连接的数据</p>
<ol start="2">
<li>分组交换与电路交换的对比<ul>
<li>分组交换不适合实时服务,因为它的端到端时延是可变和不可预测的</li>
<li>分组交换可以提供比电路交换更好的带宽共享,比电路交换更简单,更有效,实现成本更低</li>
<li>电路交换不考虑需求,而预先分配了传输链路的使用,使得已分配而不需要的链路时间未被使用</li>
<li>分组交换按需分配链路使用,链路传输能力将在所有需要在链路上传输分组的用户之间逐分组的被共享</li>
</ul>
</li>
</ol>
<h4 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h4><p>端系统(PC,智能手机,Web服务器,电子邮件服务器等)经过一个接入ISP与因特网相连,该接入ISP能够体统有线或无线连接,使用了包括DSL,电缆,FTTH,WiFi和蜂窝等多种接入技术</p>
<p>同时,接入的ISP自身必须互联,通过创建网络的网络可以实现,目标是使所有端系统能够彼此发送分组</p>
<ul>
<li>网络结构1: 用单一的全球传输ISP互联所有接入ISP,接入的ISP(<strong>客户</strong>)向全球传输ISP(<strong>提供商</strong>)付费</li>
<li>网络结构2:由数十万接入ISP和多个全球传输ISP组成,同样的这些全球传输ISP之间必须是互联的<br>这是一个两层的等级结构,全球传输提供商位于顶层接入ISP位于底层,现实中,在任何给定的区域可能有一个区域ISP(regional ISP)区域中的接入ISP与之相连,每个区域ISP则于第一层ISP(tier-1 ISP)连接,<em>大约有几十个第一层ISP,包括Level3 Communications, AT&amp;T, Sprint, NTT</em></li>
<li>网络结构3: 在这个等级结构的每一层都有客户-提供商关系,但是第一层ISP不向任何人付费,这个多层等级结构与现在的互联网粗略近似</li>
</ul>
<p>为了建造一个与今天的因特网更为详细的网络,我们许哟啊在等级化网络结构3上增加存在点(Point of Presence, PoP), 多宿,对等和因特网交换点,PoP存在与等级结构的所有层次,除了底层(接入ISP),一个PoP是由提供商网络中的一台或多台路由器(在相同位置)群组,其中客户ISP能够与提供商ISP连接,对于要与提供商PoP连接的客户网络, 它能从第三方电信提供商租用高速链路将它的路由器之一直接连接到位于该PoP的一台路由器,任何ISP(除了第一层ISP)可以选择多宿(multi-home)即可以与两个或更多提供商ISP连接</p>
<p>位于相同等级结构层次的连接一堆ISP能够<strong>对等(peer)</strong>,能够直接把它们的网络连到一起,使它们之间的所有流量直接传输而不是通过上游的中间ISP传输,当两个ISP对等的时候通常不进行结算,第三方公司能够船舰一个<strong>因特网交换点(Internet Exchange Point, IXP)</strong> IXP使多个ISP在这里一起对等</p>
<ul>
<li>网络结构4:由接入ISP,区域ISP,第一层ISP,PoP,多宿,对等和IXP组成</li>
<li>网络结构5—- </li>
</ul>
<h3 id="分组交换网中的时延-丢包和吞吐量"><a href="#分组交换网中的时延-丢包和吞吐量" class="headerlink" title="分组交换网中的时延,丢包和吞吐量"></a>分组交换网中的时延,丢包和吞吐量</h3><p>在理想状态下, 我们希望因特网服务能够在任意两个端系统呢能够随心所欲的瞬间移动数据而没有任何数据丢失</p>
<h4 id="分组交换网中时延概述"><a href="#分组交换网中时延概述" class="headerlink" title="分组交换网中时延概述"></a>分组交换网中时延概述</h4><p>分组从一个源出发,通过一系列路由器出阿叔,在i另一台主机中结束它的历程,当分组从一个节点沿这条路径到后继节点,该分组在沿途的每个节点经受了集中不同类型的时延:<strong>节点处理时延(nodal processing delay)</strong>,<strong>排队时延(queuing delay)</strong>, <strong>传输时延(transmission delay)<strong>和</strong>传播时延(propagation delay)</strong> 这些时延总体累加起来是<strong>节点总时延(total nodal delay)</strong></p>
<ul>
<li><p>时延的类型</p>
<p>一个分组从上游节点通过路由器A向路由器B发送,路由器A具有通往路由器B的出链路,该链路前面有一个队列(也称为缓存),当分组从上游节点到达路由器A的时候,路由器A检查该分组的首部,以决定它的适当出里娜鲁,并将该分组导向该链路</p>
<ul>
<li><p>处理时延</p>
<p>检查分组首部和决定该分组导向何处所需要的时间是处理时延的一部分,也包括检查比特级别的差错选哟的时间</p>
</li>
<li><p>排队时延</p>
<p>在队列中,当分组在链路上等待传输的时候,一个特定分组的配对时延长度取决于嫌弃到达的证字啊排队等待向链路传输的分组数量</p>
</li>
<li><p>传输时延</p>
<p>假定分组以先到先服务方式传输,仅当所有已经到达的分组被传输后,才能传输刚到达的分组,用L比特表示该分组的长度,用Rbps表示从路由器A到路由器B的链路传输速率,传输时延是L/R,这是将所有分组的比特推向链路所系哟啊的时间</p>
</li>
<li><p>传播时延</p>
<p>一旦一个比特别推向链路,该比特需要向路由器B传播,从该来南路的起点,到路由器B所需要的时间是传播时延,取决于该链路的物理媒体(光纤,双绞铜线等),等于或略小于光速</p>
</li>
<li><p>传输时延和传播时延的比较</p>
<p>传输时延是路由器推出分组所需要的时间,是分组长度和链路传输速率的函数,两台路由器的距离无关,传播时延是一个比特从一台路由器传播到另一台路由器所需要的时间,是两个路由器之间距离的函数</p>
</li>
</ul>
<p>这些时延对一台路由器的最大吞吐量有重要影响,最大吞吐量是一台路i尤其能偶转发分组的最大速率</p>
<h3 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a>排队时延和丢包</h3><p>与其他三个时延不同的是,排队时延对不同分组可能是不同的,如果10个分组同时到达空队列,传输的第一个分组没有排队时延,而传输的最后一个分组见经受相对大的排队时延,(这时它要等待其他9个分组被传输),当表征排队时延的时候,人们通常用统计量来度量,如平均排队时延,排队时延的方差,和排队时延超过某些特定值的概率</p>
<p>排队时延很大程度上取决于流量到达该队列的速率里娜鲁的传输速率和到达流量的性质,(流量是周期性到达还是以突发形式到达),</p>
<p>假定a是分组到达队列的平均速率(分组/秒 pkt/s),R是传输速率, 所有分组都是由L比特构成的,比特到达队列的平均速率是La bps,比率La/R称为流量强度,如果流量强度&gt;1 则比特到达队列的平均速率超过从该队列传输出去的速率,该队列趋向于无限增加,排队时延趋向于无穷大</p>
<blockquote>
<p>流量工程的一条金科玉律是:设计系统时流量强度不能大于1</p>
</blockquote>
<p>当流量强度&lt;=1是,到达流量的性质影响排队时延,如果分组周期性到达,即每L/R到达一个分组,则每个分组将到达一个空队列中,不会由排队时延,如果每(L/R)N秒同时到达N个分组,则传输的第一个分组没有排队时延,传输的第二个分组就有L/R的排队时延,第n个传输的分组具有(n-1)L/R的排队时延</p>
<p>但是到达队列的过程通常是随机的,通过统计发现,随着流量强度接近1,平均排队长度变得越来越长,时延将迅速增加</p>
<ul>
<li>丢包: 一条链路前的队列只有有限的容量,当一个到达的分组发现一个慢的队列,由于没有地方存储这个分组,路由器将丢弃该分组,该分组就会丢失</li>
</ul>
<p>丢失的分组可能基于端到端的原则重传,以确保所有的数据最终从源传送到了目的地</p>
</li>
</ul>
<h4 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h4><p>节点时延累加卡里得到端到端时延</p>
<ol>
<li><p>traceroute</p>
<p>我们可以利用Traceroute程序,traceroute从源主机中朝着目的地发送多个特殊的分组,当路由器接受到这些特殊分组之一时,向源回送一个段报文,包括路由器的名字和地址,同时源记录从发出一个分组到接收到返回报文所经历的时间,用于确定所有中间路由器的往返时延,(traceroute对上述过程会重复三次)</p>
</li>
<li><p>端系统,应用程序和其他时延</p>
<p>希望向共享媒体(例如在WiFi或电缆调制解调器情况下)传输分组的端系统可能有意的延迟它的传输,作为它与其他杜纳系统共享媒体的协议的一部分;还有媒体分组化时延,这种时延出现在IP语音(VoIP)应用中,在VoIP中,发送方在向因特网传输分组之前必须先用编码的数字化语音填充一个分组这个填充分组的时间称为分组化时延</p>
</li>
</ol>
<h4 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h4><p>除了时延和丢包,计算机网络中另一个至关重要的性能测度时端到端吞吐量,</p>
<p>在任何时间瞬间的**瞬时吞吐量(instantaneous throughput)shi主机B接受到该文件的速率,如果文件由F比特组成,主机B接受到所有F比特用了T秒,则文件的平均吞吐量为F/T bps</p>
<h3 id="协议层次及器服务模型"><a href="#协议层次及器服务模型" class="headerlink" title="协议层次及器服务模型"></a>协议层次及器服务模型</h3><h4 id="分层的体系结构"><a href="#分层的体系结构" class="headerlink" title="分层的体系结构"></a>分层的体系结构</h4><p>利用分层的体系结构,我们可以讨论一个大而复杂系统的定义良好的特定部分,这种模块化使得某层提供的服务实现易于改变,只要该层堆其上层提供相同的服务,且使用来自下层的相同服务,当某层的实现变化时,该系统的其余部分保持不变,可以用不同的方式实现该功能,提供了便于更新,改变服务的优点</p>
<ol>
<li><p>协议分层</p>
<p>网络设计者以**分层(layer)**的方式组织协议以及实现这些协议的网络硬件和软件</p>
<p><strong>服务模型</strong>:某层向它的上一层提供的<strong>服务</strong></p>
<p>一个协议层能够用如软件,硬件或两者结合来实现</p>
<p>各层的所有协议被称为<strong>协议栈(protocal stack)</strong>,因特网的协议栈由五个层析组成,物理层,链路层,网络层,交换层,应用层</p>
<ol>
<li><p>应用层</p>
<ul>
<li>协议: HTTP(提供Web文档的请求和传送),SMTP(提供电子邮件报文的传送)和FTP(提供两个端系统之间的文件传送),DNS(域名解析系统)</li>
<li>应用层协议分布在很多个端系统上,一个端系统的应用程序使用协议与另一个端系统中的应用程序交换信息分组,这种为与应用层的信息分组称为<strong>报文(message)</strong></li>
</ul>
</li>
<li><p>运输层</p>
<p>因特网的运输层在应用程序端点之间传送应用层报文,在因特网中由两种运输协议,TCP和UDP</p>
<ul>
<li>TCP向应用程序提供了面向连接的服务,包括应用层报文向目的地的确保传递和流量控制,TCP也将常保问花纹为短报文,提供拥塞控制机制</li>
<li>UDP向应用程序一共无连接服务,没有可靠性,没有流量控制,没有拥塞控制</li>
</ul>
<p>运输层的分组称为<strong>报文段(segment)</strong></p>
<p>UDP:</p>
<ul>
<li>Source Port:少于1024的是常见的服务端口,53(DNS服务器端口),通过这个判断客户和服务</li>
<li>Destination Port</li>
<li>Length</li>
<li>Checksum</li>
</ul>
</li>
<li><p>网络层</p>
<p>网络层负责将**数据报(datagram)**的网络层分组从一台主机移动到另一台主机,网络层包括著名的国际协议IP</p>
<p>该协议定义了在数据报中的各个字段以及端系统和路由器如何作用与这些字段</p>
<p>网络层也包括界定路由的路由选择协议,根据路由将数据报从源传输到目的地</p>
<p>数据报:首部+网络层数据</p>
<p>首部:</p>
<ul>
<li>前四个比特是版本号:IPv4,版本号决定了数据首部的结构</li>
<li>首部长度:(首部是可变的)</li>
<li>Differentiated Services Field:<br>Total Length:记流量用的这个<br>Identidication:</li>
<li>flags<br>TTL<br>Protocal:指出交给运输层的哪一个协议<br>Header checksum<br>Source<br>Destination</li>
</ul>
</li>
<li><p>链路层</p>
<p>将分组从一个节点(主机或路由器)移动到路径上的下一个节点,网络层必须依靠链路层的服务,网络层将数据报下穿给链路层,链路层沿着路径将数据报传给下一个点,在下一个节点,链路层将数据报上传给网络层</p>
<p>协议: 以太网,WiFi和电缆接入网的DOCSIS协议,链路层的分组称为<strong>帧(frame)</strong></p>
<p>数据链路层的帧结构只在自己的网络里面传输,帧的结构也是只在自己的网络中才有意义</p>
<p><strong>帧</strong>:首部,三个字段:</p>
<ul>
<li>Destination目的地址(mac地址):可以是广播地址,可以发给自己的网关(在路由器中转发,在另一个网络中重新封装)</li>
<li>源mac地址</li>
<li>类型:交给网络层的哪个协议</li>
</ul>
<p>mac地址:16进制,6段,48bit,前24bit是厂商标识,后24bit是厂商下网卡标识,2^24个mac地址不够,无法唯一标识一个主机,但是在同一局域网中,厂商会避免给同一批次的主机用相同mac地址的网卡</p>
</li>
<li><p>物理层</p>
<p>协议:eg:以太网中的物理层协议,关于双绞铜线,同轴电缆,光纤等等</p>
</li>
</ol>
</li>
<li><p>OSI模型</p>
<p>国际标准化组织(ISO)提出计算机网络围绕7层来组织,称为开放系统互连(OSI)模型:应用层,表示层,会话层,运输层,网络层,数据链路层,物理层</p>
</li>
</ol>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>数据从发送段系统的协议栈向下,沿着中间的链路层交换机和路由器的的协议栈,向上到达接收端系统的协议栈</p>
<p>链路层交换机实现了第一层和第二层,路由器实现了第一层到第三层</p>
<p><strong>封装(encapsulation)</strong>:在发送主机端,一个应用层报文,被传输到运输层,在最简单的情况下,运输层收到报文并附上附加信息(运输层首部信息),该首部将被接受段的运输层使用,应用层报文和运输层首部信息一起构成了<strong>运输层报文段(transport-layer segment)</strong>,运输层报文段因此封装了应用层报文.附加的信息也许包括了:允许接受段运输层向上向适当的应用程序交付报文的信息,差错检测位信息.运输层向网络层传递该报文段,网络层增加了如源和目的端系统地址,等网络层首部信息,生成了<strong>网络层数据报(network-layor datagram)</strong>,该数据报接下来被传输给链路层,链路层增加自己的链路层首部信息生成<strong>链路层帧(link-layor frame)</strong>,在每一层,一个分组具有两个类型的字段,首部自读那和<strong>有效载荷字段(payload field)</strong></p>
<h3 id="面向攻击的网络"><a href="#面向攻击的网络" class="headerlink" title="面向攻击的网络"></a>面向攻击的网络</h3><ol>
<li><p>经过因特网将有害程序放入计算机</p>
<p>通过恶意软件进入并感染我们的设备,删除我们的文件,安装间谍软件来收集隐私信息:社会保险号,口令,击键,再通过互联网发给攻击方,受害网络统称为<strong>僵尸网络</strong></p>
<p>多数恶意软件是自我复制的</p>
<ul>
<li>病毒,需要某种形式的用户交互来感染用户设别的恶意软件,如包含恶意可执行代码的电子邮件附件</li>
<li>蠕虫:无需任何明显用户交互就能进入设备的恶意软件</li>
</ul>
</li>
<li><p>攻击服务器和网络基础设施</p>
<p><strong>拒绝服务攻击(Denial-of-Service (Dos) attack)</strong>:使得网络,主机和其他基础设施部分不能由合法用户使用,Web服务器.电子邮件服务器,DNS服务器和机构网络都是DoS攻击的目标</p>
<ul>
<li>弱点攻击</li>
<li>带宽洪泛:eg:分布式Dos(Distributed Dos,DDoS)</li>
<li>连接洪泛</li>
</ul>
</li>
<li><p>嗅探分组</p>
<p>分组嗅探器:记录每个流经的分组副本</p>
</li>
<li><p>伪装成信任的人</p>
<p>IP哄骗(IP spoofing),ARP欺骗</p>
</li>
</ol>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>从定义关键的应用层概念开始，包括应用程序所需要的网络服务，客户和服务器，进程和运输层接口。考察集中网络应用程序:web, 电子邮件，对等文件分发和视频流。设计开发运行子啊TCP和UDP上的网络应用程序。学习套接字接口，学习用python写一些简单的CS应用程序</p>
<h3 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h3><p>研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序，我们需要编写能够在多台端系统上运行的软件，可以用不同的语言来编写，不需要写在网络核心设备如路由器或链路层交换机上运行的软件，</p>
<h4 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h4><p>从应用程序开发者的角度来看，网络体系结构是固定的，并为应用程序提供了特定的服务集合，另一方面<strong>应用程序体系结构</strong>由应用程序研发者设计，规定了入俄在各种端系统上组织该应用程序。应用研发者可以利用仙子啊网络应用程序中所使用的两种主流体系结构之一，客户服务器体系结构，或对对等(P2P)体系结构.</p>
<ul>
<li><p>客户-服务器体系结构</p>
<p>在<strong>客户-服务器体系结构</strong>(client-server architecture)中,有一个总是打开的主机称为服务器,服务于来自许多其他陈伟客户的主机的请求<br>在这个体系中,客户之间相互不直接通信,同时,服务器有固定的,周知的地址,称为IP地址,因为服务器总是打开的,客户总是能够通过向该服务器的IP地址发送分组来与其联系</p>
<p>客户-服务器体系结构包括:web, telnet和电子邮件</p>
<p>在客户-服务器应用中,会出现一台单独的服务器主机跟不上他所有客户请求的情况 ,需要配置大量主机的<strong>数据中心</strong>,</p>
</li>
<li><p>p2p体系结构</p>
<p>在p2p体系结构中,对位于数据中心的专用服务器有最小的依赖,应用在间断连接的主机之间使用直接通信,这些主机被称为<strong>对等方</strong></p>
<p>包括:文件共享(BitTorrent), 对等方协助下载加速器(迅雷), 因特网电话和视频会议(Skype)</p>
<p>某些应用具有混合的体系结构,结合了客户-服务器和P2P元素,对于很多即使讯息系统而言,服务器被用于跟踪用户的IP地址,但用户到用户的报文,在用户主机之间直接发送</p>
<p><strong>自扩展性</strong>,在P2P文件共享应用中,尽管每个对等方都由于请求文件产生工作负担,但每个对等方通过向其他对等方分发文件也为系统增加服务能力, P2P还有其成本效率,因为通常不需要庞大的服务器基础设施,和服务器带宽</p>
<p>面临安全性,性能和可靠性等挑战</p>
</li>
</ul>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p>我们关注在不同端系统上的进程的通信:在两个不同端系统上的进程,通过跨越计算机网络交换<strong>报文</strong>,进行通信,发送进程生成并向网络中发送报文,接收进程接收这些报文并可能通过会送报文进行响应</p>
<ol>
<li><p>客户和服务器进程</p>
<p>网络应用程序由成对的进程组成,这些进程通过网络相互发送报文.我们通常将两个进程之一标识为<strong>客户(client)<strong>另一个标识为</strong>服务器(server)</strong><br>在P2P文件共享系统中,一个进程即可以上载文件由可以下载文件,即可以是客户又可以是服务器:定义客户和服务器:</p>
<blockquote>
<p>在一对进程之间的通信会话场景中,发起通信(即在该会话开始时发起与其他进程的联系)的进程被标识为<strong>客户</strong>,在会话开始时等待联系的进程时<strong>服务器</strong></p>
</blockquote>
</li>
<li><p>进程与计算机网络之间的接口</p>
<p>从一个进程向另一个进程发送的报文必须通过下面的网络,进程通过一个称为<strong>套接字</strong>(socket)的软件接口向网络发送报文和从网络接收报文</p>
<p>套接字是同一台主机内应用层与运输层的接口,也称为<strong>应用程序编程接口</strong></p>
<p>应用程序开发者对于运输层的控制权限仅限于:</p>
<ol>
<li>选择运输层协议</li>
<li>设定几个运输层参数:如最大缓存和最大报文段长度</li>
</ol>
</li>
<li><p>进程寻址</p>
<p>为了标识接收进程,需要定义两种信息</p>
<ol>
<li>主机地址:在因特网中主机由<strong>IP地址</strong>标识</li>
<li>目的主机中接收指定进程的标识符:<strong>目的端口号</strong>用于标识发送进程在主机上的接收套接字</li>
</ol>
</li>
</ol>
<h4 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h4><p>在发送段的应用程序将报文推进该套接字,运输层协议负责从接收进程的套接字得到该报文</p>
<p>能够从四个方面对应用程序服务要求进行分类:可靠数据传输,吞吐量,定时和安全性</p>
<ol>
<li><p>可靠数据传输</p>
<p>对于一些服务,数据丢失会造成灾难性的后果,一个协议提供了确保数据交付服务就认为提供了<strong>可靠数据传输</strong>,当一个运输协议提供这种服务时,发送进程只要将数据传递给套接字就可以完全相信该数据将能无差错的到达接收进程</p>
<p>当一个运输层协议不提供可靠数据传输的时候,由发送进程发送的数据可能到不了接收进程,有一些应用可以容忍丢失,如:交谈式音频视频,可以承受一定量的数据丢失</p>
</li>
<li><p>吞吐量</p>
<p>可用吞吐量:发送进程能够向接收进程交付比特的速率</p>
<p>运输层协议能够以某种特定的速率提供确保可用吞吐量,有些接收应用程序如:因特网电话服务,接收所需吞吐量的一半的时候是完全没有意义的,这些称为<strong>敏感带宽应用</strong></p>
<p><strong>弹性应用</strong>:能够更具当前可用带宽或多或少地利用可供使用的吞吐量</p>
</li>
<li><p>定时</p>
<p>定时保证,能够以多种形式实现:发送方注入套接字中的每个比特到达接收方的套接字不迟于100ms</p>
</li>
<li><p>安全性</p>
<p>加密由发送进程传输的所有数据,运输层协议能够将数据交付给接收进程之前解密这些数据,运输协议还提供除了机密性以外的安全性服务,包括数据完整性和端点识别</p>
</li>
</ol>
<h4 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h4><ol>
<li><p>TCP服务</p>
<ul>
<li><p>面向连接的服务:在应用层数据报文开始流动之前,TCP先让客户和服务器互相交换运输层控制信息.在握手阶段后,一个TCP连接在两个进程之间的套接字之间建立,当应用程序结束报文发送的时候,必须拆除该连接</p>
</li>
<li><p>可靠数据传输服务:通信进程能够依赖TCP,无差错,按适当顺序交付所有发送的数据</p>
</li>
<li><p>TCP还有拥塞控制机制,当发送方和接收方之间的网络出现拥塞时,TCP的拥塞控制机制会抑制发送程序,它也会限制每个TCP连接,达到公平共享网络带宽的目的</p>
<blockquote>
<p>TCP还有UDP都没有任何加密机制,信息可以在任何中间链路被嗅探和发现,因为隐私和其他安全问题,研发出了TCP的加强版本:安全套接字层(Secure Sockets layer, SSL),这个加强是在应用层上实现的,</p>
</blockquote>
</li>
</ul>
</li>
<li><p>UDP服务</p>
<p>UDP不提供不必要服务,是一种轻量级服务,仅提供最小服务,不可靠数据传输,无拥塞控制机制</p>
</li>
<li><p>因特网运输层协议不提供的服务</p>
<p>对于吞吐量和定时保证,因特网运输协议并没有提供</p>
</li>
</ol>
<h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><ul>
<li>应用层协议定义了运行在不同端系统上的应用程序进程如何互相传递报文,定义了<ul>
<li>交换的报文类型:请求报文和响应报文</li>
<li>各种报文类型的语法,如报文各个字段以及各个字段是如何描述的</li>
<li>字段的语义,即这些字段中的信息的含义</li>
<li>确定一个进程何时以及如何发送报文,对报文进行响应的规则</li>
</ul>
</li>
<li>有些应用层协议是由RCF文档定义的,位于公共域中:web应用的HTTP协议</li>
</ul>
<h4 id="本章涉及的网络应用"><a href="#本章涉及的网络应用" class="headerlink" title="本章涉及的网络应用"></a>本章涉及的网络应用</h4><p>web,文件传输,电子邮件,目录服务,流式视频和P2P</p>
<h3 id="web和HTTP"><a href="#web和HTTP" class="headerlink" title="web和HTTP"></a>web和HTTP</h3><h4 id="http概况"><a href="#http概况" class="headerlink" title="http概况"></a>http概况</h4><p>术语:</p>
<ul>
<li><strong>HTTP(HyperText Transfer Protocol),超文本传输协议</strong>, </li>
<li><strong>WEB页面</strong>:由对象组成</li>
<li><strong>对象</strong>:一个文件如:html文件,JPEG图形,Java小程序,或一个视频片段</li>
<li>多数Web页面含有一个<strong>HTML基本文件</strong>以及几个引用对象</li>
<li><strong>URL地址</strong>:由两部分组成:存放对象的服务器主机名和对象的路径名</li>
<li><strong>WEB浏览器</strong>:实现了HTTP的客户端</li>
<li><strong>WEB服务器</strong>实现了HTTP的服务器端:流行的web服务器有Apache,Microsoft Internet Information Server</li>
</ul>
<p>当用户请求一个WEB页面时,浏览器向服务器发出对该页面所博阿寒对象的HTTP请求报文,服务器接收到请求,并用包含这些对象的HTTP响应报文进行响应</p>
<p>HTTP使用TCP作为运输协议,首先发起一个与服务器的TCP连接,连接建立疑惑,浏览器和服务器进程就可以通过套接字接口访问TCP</p>
<p>服务器向客户发送被请求的文件,而不存储任何关于该客户的状态信息,假如某个特定的用户在短短几秒内两次请求同一个对象,服务器会,重新发送该对象, HTTP是一个<strong>无状态协议</strong></p>
<h4 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h4><p><strong>非持续连接</strong>:每个请求/响应对是经过TCP进行的<br><strong>持续连接</strong>:所有的请求即响应都是经过相同的TCP连接发送的</p>
<ol>
<li><p>采用非持续连接的HTTP</p>
<p>在非持续连接的情况下,从服务器向客户传送一个Web页面的步骤,假设该HTML有一个HTML基本文件和10个JPEG图形,</p>
<ol>
<li><p>HTTP客户进程在端口号80发起一个到服务器<a target="_blank" rel="noopener" href="http://www.someschool.edu的tcp连接,该端口号是http的默认端口,在客户端和服务器上分别有一个套接字与该连接相关联/">www.someSchool.edu的TCP连接,该端口号是HTTP的默认端口,在客户端和服务器上分别有一个套接字与该连接相关联</a></p>
</li>
<li><p>HTTP客户经过它的套接字向该服务器发送一个HTTP的请求报文.请求报文中包含<code>路径名/someDepartment/home.index</code></p>
</li>
<li><p>HTTP服务器进程经过它的套接字接收该请求报文,从其存储器中检索出对象<code>www.someSchool.edu/someDepartment/home.index</code>在一个HTTP的响应报文中封装对象,并通过套接字向客户发送响应报文</p>
</li>
<li><p>HTTP服务器进程通知TCP断开该TCP连接</p>
</li>
<li><p>HTTP客户接收响应报文,TCP连接关闭,该报文指出封装的对象是一个HTML文件,客户从响应报文中提取出该文件,检查该HTML文件,得到对10个JPEG图形的引用</p>
</li>
<li><p>对每个引用的JPEG图形对象重复前4个步骤</p>
</li>
</ol>
<p>在默认情况下，大部分浏览器打开5~10个并行的TCP连接，每条连接处理一个请求响应事务</p>
<p><strong>往返时间(Round-Trip Time)</strong>:一个短分组从客户到服务器然后再返回客户所花费的时间,包括分组传播时延,分组再中间路由器和交换机上的排队时延以及分组处理时延</p>
</li>
<li><p>采用持续连接的HTTP</p>
<p>非持续连接有一些缺点:</p>
<ol>
<li>必须为每个请求的对象建立和维护一个全新的连接,对每个这样的连接,再客户和服务器中都要分配TCP的缓冲区和保持TCP变量,会给Web服务器带来严重的负担</li>
<li>每个对象经受两倍RTT的交付时延</li>
</ol>
<p>在采用HTTP1.1持续连接的情况下, 服务器在发送响应后保持TCP连接打开,在相同的客户和服务器的之间,后续的请求和响应报文能够通过相同的连接进行传送,甚至位于同一个服务器的多个web页面在从该服务器发送给同一个客户的时候,可以在单个持续的TCP连接上进行</p>
<p>在HTTP2中允许子啊相同连接中多个请求和回答交错,并增加了在该链接中优化HTTP报文请求和回答的机制</p>
</li>
</ol>
<h4 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h4><p>HTTP的报文有两种:请求报文和响应报文</p>
<ol>
<li><p>HTTP请求报文</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/somedir/page.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.someschool.edu</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close		 # 告诉服务器不要麻烦地使用持续连接,要求服务器在发送完被请求的对象后就关闭这条连接</span><br><span class="line"><span class="attribute">User-agent</span><span class="punctuation">: </span>Mozilla/5.0	  # 指明用户代理,即向服务器发送请求的浏览器类型 </span><br><span class="line"><span class="attribute">Accept-language</span><span class="punctuation">: </span>fr		  # 表示用户想得到该对象的发育版本</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该报文有5行组成,每行由一个回车和换行符结束<code>\n\r</code>,最后一行后再附加一个回车换行符</p>
<p>一个请求报文能够具有更多的行或者至少为一行,</p>
<ul>
<li>HTTP请求报文的第一行叫做<strong>请求行</strong>, 请求行有三个字段:<ul>
<li>方法字段: GET, POST, HEAD, PUT, DELETE,</li>
<li>URL字段</li>
<li>HTTP版本字段</li>
</ul>
</li>
<li>后续的行叫做<strong>首部行</strong></li>
</ul>
<p>请求报文的通用格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法[sp]URL[sp]版本[cr][lf]   &lt;- 请求行</span><br><span class="line">首部字段名[sp]值[sp][cr][lf]  &lt;- 首部行</span><br><span class="line">...</span><br><span class="line">首部字段名[sp]值[sp][cr][lf]</span><br><span class="line">[cr][lf]					&lt;-空行</span><br><span class="line">...						    &lt;-实体体</span><br></pre></td></tr></table></figure>

<p>实体体:使用GET方法的时候实体体为空,使用POST方法时才使用该实体体</p>
<p>HEAD方法类似于GET方法,当服务器收到一个使用HEAD方法的请求时会用一个HTTP报文进行响应,但是不返回请求对象,应用程序开发者常用HEAD方法进行调试跟踪</p>
<p>PUT方法常与Web发行工具联合使用,允许用户上传对象到指定的Web服务器上指定的路径</p>
<p>DELETE方法允许用户或者应用程序删除Web服务器上的对象</p>
</li>
<li><p>HTTP响应报文</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">data</span><span class="punctuation">: </span>Tue, 18 Aug 2015 15:44:04 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.2.3 (CentOS)</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Tue, 18 Aug 2015 15:11:03 GMT</span><br><span class="line"><span class="attribute">Conyent-Length</span><span class="punctuation">: </span>6821</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="haskell">(<span class="class"><span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> ...)</span></span></span><br></pre></td></tr></table></figure>

<p>响应报文,三个部分:</p>
<ul>
<li>初始<strong>状态行</strong>,三个字段:<ul>
<li>协议版本字段</li>
<li>状态码</li>
<li>相应状态信息</li>
</ul>
</li>
<li>6个<strong>首部行</strong><ul>
<li><code>Connection close</code>告诉客户,发送完报文后将关闭该TCP连接</li>
<li>Date:首部行指示服务器产生并发送该相应报文的日期和时间,时服务器从它的文件系统中检索到该对象,将该对象插入响应报文,并发送该响应报文的时间</li>
<li>Server:类似于HTTP请求报文中的User-agent</li>
<li>Last-Modified:指示了对象创建或者最后修改的日期和时间</li>
<li>Content-Length:指示了被发送对象中的字节数</li>
<li>Content-Type:指示了被发送对象时HTML文本</li>
</ul>
</li>
<li><strong>实体体</strong>:报文的主要部分,包含了所请求的对象本身</li>
</ul>
<p>响应报文通用格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">版本[sp]状态码[sp]短语[cr][lf]   &lt;- 状态行</span><br><span class="line">首部字段名[sp]值[sp][cr][lf]     &lt;- 首部行</span><br><span class="line">...</span><br><span class="line">首部字段名[sp]值[sp][cr][lf]</span><br><span class="line">[cr][lf]					  &lt;-空行</span><br><span class="line">...						      &lt;-实体体</span><br></pre></td></tr></table></figure>

<p>常见的状态码和短语:</p>
<ul>
<li>200 OK:请求成功,信息在返回的响应报文中</li>
<li>301 Moved Permanently:请求的对象已经被永久转移了,新的URL定义在响应报文的Location:首部行中,客户软件将自动获取新的URL</li>
<li>400 Bad Request:一个通用的差错代码,指示该请求不能被服务器理解</li>
<li>404 Not Found: 被请求的文档不在服务器上</li>
<li>505 HTTP Version Not Supported: 服务器不支持请求报文使用的HTTP协议版本</li>
</ul>
</li>
</ol>
<h4 id="用户与服务器的交互-cookie"><a href="#用户与服务器的交互-cookie" class="headerlink" title="用户与服务器的交互:cookie"></a>用户与服务器的交互:cookie</h4><p>HTTP服务器时无状态的,web服务器希望限制用户的访问,或者希望把内容与用户身份联系起来,为此HTTP使用cookie</p>
<p>cookie有4个组件:</p>
<ol>
<li>在HTTP响应报文中的一个cookie首部行</li>
<li>在HTTP请求报文中的一个cookie首部行</li>
<li>在用户端系统中保留有一个cookie文件, 并由用户的浏览器进行管理</li>
<li>位于Web站点的一个后端数据库</li>
</ol>
<p>cookie可以用于表示一个用户,用户首次访问一个站点时,可能需要提供一个用户标识,在后续会话中,浏览器想服务器传递一个cookie首部,从而向该服务器标识了用户,cookie可以在无状态的HTTP之上建立一个用户会话层</p>
<h4 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h4><p><strong>Web缓存器</strong>也叫<strong>代理服务器</strong>,它能够代表初始Web服务器来满足HTTP请求的网络实体,Web缓存器有自己的磁盘存储空间,并在存储空间中保存最近请求过的对象的副本</p>
<ol>
<li>浏览器创建一个到Web服务器的TCP连接,并向Web缓存器中的对象发送一个HTTP请求</li>
<li>Web缓存器进行检查,看看本地是否存储了该对象副本,如果有,Web缓存器就向客户浏览器用HTTP响应报文返回该对象</li>
<li>如果Web缓存器中没有该对象,它就打开一个与该对象的初始服务器的TCP连接,Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求,在收到该请求后,初始服务器向该Web缓存器发送具有该对象的HTTP响应</li>
<li>当Web缓存器接收到该对象时,它在本地存储空间存储一份副本,并向客户的浏览器用HTTP响应报文发送该副本(通过现有的客户浏览器和Web缓存器之间的TCP连接)</li>
</ol>
<p>Web缓存器即是服务器又是客户,通常由ISP购买并安装,Web缓存器可以大大减少对客户请求的响应时间,特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽</p>
<p>通过使用**内容分发网络(Content DistributiWeb缓存器正在因特网中发挥着越来越重要的作用,CDN公司在因特网上安装了许多地理上分散的缓存器,使大量流量实现了本地化</p>
<h4 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h4><p>高速缓存可以减少用户的响应时间,但是存放在缓存器中的对象副本可能是陈旧的,<strong>条件GET</strong>方法允许缓存器证实它的对象是最新的</p>
<p>如果请求报文使用GET方法,并且请求报文中包含一个<code>If-Modified-Since:</code>首部行,那么这个HTTP请求报文就是一个条件GET请求报文</p>
<p>eg:</p>
<p>代理缓存器向某Web服务器发送一个请求报文</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /fruit/kiwi.gif HTTO/1.1</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.exotiquecuisine.com</span><br></pre></td></tr></table></figure>

<p>然后该Web服务器向缓存器发送具有被请求的对象的响应报文:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Data</span><span class="punctuation">: </span>Sat, 3 Oct 2015 15:39:29</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/1.3.0 (Unix)</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 9 Sep 2015 09:23:24</span><br><span class="line">Content-Type:image/gif</span><br><span class="line"></span><br><span class="line"><span class="haskell">(<span class="class"><span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> ...)</span></span></span><br></pre></td></tr></table></figure>

<p>该缓存器在将对象转发到请求的浏览器的同时,也在本地缓存了该对象,同时存储了最后的修改日期,在下一次另一个用户请求同一个对象的时候,该对象仍在这个缓存器中,该缓存器通过发送一个条件GET执行最新检查</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/fruit/kiwi.gif</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.exotiquecuisine.com</span><br><span class="line"><span class="attribute">If-modified-since</span><span class="punctuation">: </span>Wed, 9 Sep 2015 09:23:24</span><br></pre></td></tr></table></figure>

<p>该条件GET报文告诉服务器,仅当自指定日期后该对象被修改过,才发送该对象,如果没有被修改过,WEB服务器向该缓存器发送一个响应报文</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">304</span> Not Modified </span><br><span class="line"><span class="attribute">Data</span><span class="punctuation">: </span>Sat, 10 Oct 2015 15:39:29</span><br><span class="line">Server:Apache/1.3.0 (Unix)</span><br><span class="line"></span><br><span class="line"><span class="clojure">(<span class="name"><span class="builtin-name">empty</span></span> entity body)</span></span><br></pre></td></tr></table></figure>

<p>304 Not Modified 告诉缓存器可以使用该对象,能向请求的浏览器妆发代理缓存器缓存的对象副本</p>
<h3 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h3><p>因特网电子邮件系统,3个主要组成部分:**用户代理(user agent),邮件服务器(mail server)和简单邮件传输协议(Simple Mail Transfer Protocol, SMTP) **</p>
<p>邮件服务器形成了电子邮件体系结构的核心,每个接收方在其中的某个邮件服务器上有一个<strong>邮箱</strong></p>
<p>典型的邮件发送过程:从发送方的用户代理开始,传输到发送方的邮件服务器,再传输到接收方的邮件服务器,然后再被分发到接收方的邮箱中,如果A的服务器不能将邮件交付给B的服务器,A的邮件服务器会在一个**报文队列(message queue)**中保持该报文并再以后尝试再次发送,通常没30分钟左右进行一次尝试,如果几天以后仍然不能成功,服务器就删除该报文并以电子邮件的形式通知发送方</p>
<p>SMTP是因特网电子邮件中主要的应用层协议,使用TCP可靠数据传输服务,SMTP也有两部分,运行在发送方邮件服务器的客户端和运行在接收方邮件服务器的服务器端</p>
<h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>A向B发送一封简单的ASCII报文</p>
<ol>
<li>A调用邮件代理程序并提供B的邮件地址,写报文,然后指示用户代理发送报文</li>
<li>A的用户dialing把报文发给A的邮件服务器,在那里报文被放在报文队列里</li>
<li>运行在A的邮件服务器上的SMTP客户端发现了报文队列中的这个报文,创建一个到运行在B的邮件服务器上的SMTP服务器的TCP连接</li>
<li>在经过一些初始的SMTP握手后,SMTP客户通过该TCP连接发送A的报文</li>
<li>在B的邮件服务器上,SMTP服务器端接收这个报文.B的邮件服务器然后将该报文的放入B的邮箱之中</li>
<li>在B方便的时候,B调用用户代理阅读报文</li>
</ol>
<p>SMTP不使用中间邮件服务器发送邮件</p>
<p>SMTP客户和STMP服务器之间交换报文文本:客户的主机名为crepes.fr,服务器的主机名是hamburger.edu,SMTP握手协议:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">S:	220 hamburger.edu</span><br><span class="line">C:	HELO crepes.fr</span><br><span class="line">S:	250 Hello crepes.fr, pleased to meet you</span><br><span class="line">C:	MAIL FROM: &lt;alice@crepes.fr&gt;</span><br><span class="line">S:	250 alice@crepes.fr ... Sender ok</span><br><span class="line">C:	RCPT TO: &lt;bob@hamburger.edu&gt;</span><br><span class="line">S: 	250 bob@hamburger.edu ... Recipient ok</span><br><span class="line">C: 	DATA</span><br><span class="line">S:	354 Enter mail, end with &quot;.&quot; on a line by itself </span><br><span class="line">C:	Do you like ketchup?</span><br><span class="line">C:	How about pickles?</span><br><span class="line">C: 	.</span><br><span class="line">S:	250 Message accepted for deliery</span><br><span class="line">C: 	QUIT</span><br><span class="line">S: 	221 hamburger.edu closing connection</span><br></pre></td></tr></table></figure>

<p>客户发了五条命令：HELO, MAIL FROM, RCPT TO, DATA, QUIT</p>
<p>客户端通过发送一个只包含句点的行,向服务器指示该报文结束了每个报文以CRLF.CRLF结束</p>
<h4 id="与HTTP的对比"><a href="#与HTTP的对比" class="headerlink" title="与HTTP的对比"></a>与HTTP的对比</h4><ul>
<li>HTTP是一个<strong>拉协议</strong>,即在方便的时候,某些人在Web服务器上装载信息,用户使用HTTP从该服务器拉取这些信息,特别是TCP连接是由想接收文件的机器发起的,SMTP是一个<strong>推协议</strong>,发送邮件服务器把文件推向接收邮件服务器,这个TCP连接时有要发送该文件的机器发起的</li>
<li>SMTP要求每个报文,再用7比特ASCII码格式,HTTP不受这个限制</li>
<li>处理一个即包含文本又包含图形的文档,HTTP把每个对象封装子啊自己的HTTP响应报文中,SMTP把所有报文对象房子啊一个报文中</li>
</ul>
<h4 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h4><p>一个人给另一个人发送电子邮件时,一个包含环境信息的首部位于报文体前面,这些环境信息包括在一系列首部行中m首部行和该报文的体用空行进行分隔</p>
<p>每个首部必须含有一个From: 和一个To: 一个首部也许包含一个Subject: </p>
<h4 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h4><p>SMTP协议是推协议,但是取报文是拉操作:通过引入一个特殊的邮件访问协议来解决这个问题:<strong>第三版的邮局协议(Post Office Protocol–version 3, POP3)</strong></p>
<ol>
<li><p>POP3</p>
<p>POP3按照三个阶段进行工作: </p>
<ul>
<li><p>特许(authorization):用户代理发送(以明文形式)用户名,和口令以鉴别用户</p>
<ul>
<li><p>两个主要命令:</p>
<ul>
<li><p>user &lt;user name&gt;</p>
</li>
<li><p>pass &lt;password&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+OK POP3 server ready</span><br><span class="line">user bob</span><br><span class="line">+OK</span><br><span class="line">pass hungry</span><br><span class="line">+OK user successfully logged on</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>事务处理,用户代理取回报文,对报文做删除标记,取消报文删除标记,以及获得邮件的统计信息</p>
</li>
<li><p>更新:在用户发出quit命令之后,目的是结束该POP3会话,这时,该邮件服务器删除哪些被标记为删除的报文</p>
</li>
</ul>
<p>POP3的事务处理过程中,用户代理发出一些命令,服务器对每个命令做出回答,两种:+OK(有时后面还跟有服务器到客户的数据),被服务器用来指示前面的命令是正常的;-ERR, 被服务器用来指示前面的命令出现了某些差错</p>
<p>用户代理首秀按请求邮件服务器列出所有存储的报文的长度,接着用户代理从邮件服务器取回,并删除每封邮件.</p>
<p>在特许阶段以后,用户代理仅使用四个命令:list, retr, dele, quit</p>
<p>在用户代理与邮件服务器之间的POP3会话期间,该POP3服务器保留了一些状态信息,特别是记录了哪些用户报文被标记为删除了,然而POP3服务器,并不在POP3会话过程中携带状态信息</p>
</li>
<li><p>IMAP</p>
<p>使用POP3访问的时候,一旦B将邮件下载到本地后,就能建立邮件文件夹并将下载的邮件放入该文件夹,然后b可以删除报文,在文件夹之间移动报文,并查询报文,但是这种方式,会给移动用户带来问题,无法在远程服务器上操作文件,没法做到从任何一台机器上对所有的报文进行访问,POP3做不到</p>
<p>IMAP服务器把每个报文与一个文件夹联系起来,当报文第一次到达服务器时,它与收件人的INBOX文件夹相关联,收件人可以把邮件一道一个新的,用户创建的文件夹中,实现各种操作,</p>
<p>IMAP允许用户代理获取报文某些部分,可以只读取一个报文的报文首部,或多部分MIME报文的一部份,当用户代理和其邮件服务器之间使用低带宽连接的时候,这个特性很有用</p>
</li>
<li><p>基于Web的电子邮件</p>
<p>使用这种服务, 用户代理就是普通的浏览器,当一个收件人,想从他的邮箱中访问一个报文时,该电子邮件报文从他的邮件服务器发送到发的浏览器,直接用HTTP协议,发送的时候也用HTTP,但是在他的邮件服务器与其他服务器之间发送和接收的时候,还是用SMTP</p>
</li>
</ol>
<h3 id="DNS-因特网的目录服务"><a href="#DNS-因特网的目录服务" class="headerlink" title="DNS:因特网的目录服务"></a>DNS:因特网的目录服务</h3><p>主机的一种标识方法是用它的<strong>主机名(host name)</strong>,但是主机名没有提供主机在因特网中的位置的信息,而且主机可能由不定长的字母数字组成,路由器很难处理,因此主机也可以使用所谓的<strong>IP地址</strong>标识</p>
<h4 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h4><p>为了折衷路由器和人类的偏好,我么需要一种能够进行主机名到IP地址转换的目录服务,<strong>域名系统(Domain Name System, DNS)</strong></p>
<p>DNS由:一个分层的DNS服务器是实现分布式数据库;一个使得主机能够查询分布式数据库的应用层协议</p>
<p>DNS服务器通常是运行BIND(Berkeley Internet Name Domain)软件的UNIX机器,运行在UDP上使用53号端口</p>
<p>DNS通常是由其他应用层的协议所使用的,将客户提供的主机名解析为IP地址</p>
<ol>
<li>同一台用户主机上运行者DNS应用的客户端</li>
<li>浏览器从上述URL中抽取出主机名,并将这台主机名传给DNS应用的客户端</li>
<li>DNS客户向DNS服务器发送一个包含主机名的请求</li>
<li>DNS客户最终会收到一份回答报文,其中由对应与该主机名的IP地址</li>
<li>一旦浏览器接收到来自DNS的该IP地址,它能够向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接</li>
</ol>
<p>DNS还提供一些重要的服务:</p>
<ul>
<li>主机别名: 有着复杂主机名的主机能拥有一个或多个别名:eg:relay1.west-coast.enterprise.com可能还有别名为enterprise.com,前者被称为<strong>规范主机名</strong>,主机别名比规范主机名更加容易记忆</li>
<li>邮件服务器别名:同理,邮件地址也需要有更好记的名字</li>
<li>负载分配:DNS也用在冗余的服务器之间进行负载分配,繁忙的站点,被冗余分布在多台服务器上,每台服务器均运行在不同的端系统上,有着不同的IP地址,但是与同一个规范主机名相联系.当客户对应着到某地址集合的名字发出一个DNS请求的时候,该服务器用IP地址的整个集合进行响应,但在每个回答中循环这些地址次序,因为客户从事相IP地址排在最前面的服务器发送HTTP请求报文,起到了分配冗余的服务器之间负载的作用,同样可以用于邮件服务器</li>
</ul>
<h4 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a>DNS工作机理概述</h4><p>某些应用陈虚谷需要将主机名转换成IP地址,这些应用程调用DNS的客户端,并指明需要被转换的主机名,用户主机上的DNS接收到以后,相网络中发送一个DNS查询报文(53端口),经过若干毫秒的时延后,用户主机上的DNS接收到一个提供所希望映射的DNS回答报文</p>
<p>DNS服务器的一种简单设计是,将所有的查询直接发往单一的DNS服务器,同时该DNS服务器直接对所有的查询客户做出响应,当今这种集中式的设计有很多问题:</p>
<ul>
<li>单点故障:如果该DNS服务器奔溃,整个因特网都崩了</li>
<li>通信容量:单个DNS服务器不得不处理所有的DNS查询</li>
<li>远距离的集中式数据库,单个DNS服务器不可能邻近所有查询客户,将导致严重的时延</li>
<li>维护单个DNS服务器将不得不为所有的因特网主机保留记录,者不仅将是这个中央数据库庞大,而且他还不得不为解决每个新添加的主机而频繁更新</li>
</ul>
<p>分布式数据库:</p>
<ol>
<li><p>分布式,层次数据库</p>
<p>为处理扩展性问题,DNS使用了大量的DNS服务器,以层次方式组织,并且分布在全世界范围内,大致有3种类型的DNS服务器:</p>
<ul>
<li><p>根DNS服务器:400多个根名字服务器遍及全世界,由13个不同组织管理,根名字服务器提供TLD服务器的IP地址</p>
</li>
<li><p>顶级域DNS服务器:对于每个顶级域(com, org, net, edu, gov)和所有国家的顶级域(uk, fr, ca, jp)都有TLD服务器,TLD服务器提供了权威DNS服务器的IP地址</p>
</li>
<li><p>权威DNS服务器:在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录：eg：ppsuc.edu.c</p>
<ul>
<li>静态：当前域下的对外提供服务的IP和域名的对应关系</li>
<li>缓存：其余用户主机使用本地域名解析服务器的时候，缓存的</li>
</ul>
<p>还有一类重要的DNS服务器,<strong>本地DNS服务器</strong>,每个ISP都有一台本地DNS服务器,它起到代理的作用,并将该请求转发到DNS服务器的层次结构中</p>
<p>eg:假设主机cse.nyu.edu想知道主机gaia.cs.umass.edu的IP地址,同时csu.nyu.edu主机的本地DNS服务器为dns.nyu.edu并且gaia.cs.umass.edu的权威DNS服务器为dns.umass.edu.主机cse.nyu.edu首先向它的本地DNS服务器发送一个查询报文,然后本地DNS服务器将该报文转发到根DNS服务器,根DNS服务器注意到edu前缀,并向本地DNS服务器返回负责edu的TLD的IP地址列表,本地DNS服务器再次向这些TLD服务器之一发送查询报文,该TLD服务器注意到是umass.edu前缀,用权威DNS服务器的IP地址进行响应,该权威DNS服务器是负责马萨诸塞大学的dns.umass.edu最后本地DNS服务器直接向dns.umass.edu重发查询报文(共法律8份DNS报文:4份查询和4份回答)<strong>递归查询</strong>和<strong>迭代查询</strong></p>
</li>
</ul>
</li>
<li><p>DNS缓存:</p>
<p>本地DNS服务器能够将映射缓存在本地存储器中,另一台对相同主机名的查询到达该DNS服务器时,该DNS服务器就能够提供所要求的地址,DNS服务器在一段时间后(一般是两天)丢弃缓存的信息</p>
</li>
</ol>
<h4 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h4><p>共同实现DNS分布式数据库的所有DNS服务器存储了<strong>资源记录</strong>(Resource Record),RR提供了主机名到IP地址的映射,每个DNS回答报文包含了一条或多条资源记录</p>
<p>资源记录时一个包含了下列字段的4元组<code>(Name, Value, Type, TTL)</code></p>
<ul>
<li>Type = A 则Name是主机名,Value时该主机名对应的IP地址</li>
<li>Tpye = NS 则那么是一个, 而Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名</li>
<li>Type = CNAME, Value是别名为Name的主机对应的规范主机名,</li>
<li>Type = MX, Value是个别名为Name的邮件服务器的规范主机名</li>
</ul>
<ol>
<li><p>DNS报文:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">标识符		|	标志		</span><br><span class="line">问题数		| 	回答RR数	</span><br><span class="line">权威RR数	|	附加RR数	&lt;- 共12字节</span><br><span class="line">问题(问题的变量数)		   &lt;- 查询的名字和类型字段</span><br><span class="line">回答(资源记录的变量数)	  &lt;- 对查询的响应中的RR</span><br><span class="line">权威(资源记录的变量数)	  &lt;-权威服务器的记录</span><br><span class="line">附加信息(资源记录的变量数)	 &lt;-可被使用的附加&quot;有帮助的&quot;信息</span><br></pre></td></tr></table></figure>

<ul>
<li><p>前12个字节是首部区域</p>
<ul>
<li><p>第一个字段是一个16比特的数,用于标志该查询,这个标志符会被复制到对查询的回答报文中,一边给让客户用它来匹配发送的请求和接收到的回答</p>
<ul>
<li>1比特查询/回答标志位指出报文是查询报文(0)还是回答报文(1)</li>
<li>某DNS服务器是所请求名字的权威DNS服务器时,1比特的权威的标志位</li>
<li>1比特希望递归标志位,在它的回答报文中会对1比特递归可用标志位置位,还有4个关键数量的字段,指出在首部后的4类数据区域出现的数量</li>
</ul>
</li>
<li><p>问题区域包含着正在进行的查询信息</p>
<ul>
<li>名字字段,包含正在被查询的主机名字</li>
<li>类型字段,指出有关该名字正被询问的问题类型</li>
</ul>
</li>
<li><p>在来自DNS服务器的回答中,回答区域包含了对最初请求的名字的资源记录,</p>
</li>
<li><p>权威区域包含了其他权威服务器的记录</p>
</li>
<li><p>附加区域包含了其他有帮助的记录</p>
<p>使用nslookup程序能够向某些DNS服务器发送一个DNS查询报文</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在DNS数据库中插入记录</p>
<p>我们需要在注册登记机构注册域名,向某些注册等级机构注册域名时,需要向该机构提供基本的辅助权威DNS服务器的名字和IP地址</p>
</li>
</ol>
<h3 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h3><ol>
<li><p>P2P体系结构的扩展性</p>
<p>每个对等方能够帮助服务器分发文件,当对等方接收到某些文件数据,它能够用自己的上载能力重新将数据分发给其他对等方</p>
<p>对等方除了是比特的消费者外还是他们的重新分发者.</p>
</li>
<li><p>BitTorrent</p>
<p>用于文件分发的P2P协议,参与一个特定文件分发的所有对等方的集合被称为一个洪流(torrent),在一个洪流中的对等方彼此下载等长度的文件块（thunk）,典型的块长度为256KB<br>当一个对等方加入某洪流时，它向追踪器注册自己，并周期性地通知追踪器它仍在该洪流中，以这种方式，追踪器跟踪参与在洪流中的对等方</p>
<p>当一个新的对等方加入洪流的时候，追踪器随机地从参与对等方地集合中选择对等方地一个子集，并将这些对等方地IP地址发送给新的对等方，新的对等方会试图与该列表上的所有对等方创建并行的TCP连接<br><strong>最稀缺优先</strong>：针对对等方自己本身没有的块在邻居中决定最稀缺的块，首先请求最稀缺的块，让最稀缺块更为快速地重新分发，均衡每个块在洪流中的副本数量</p>
</li>
</ol>
<h3 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h3><h4 id="因特网视频"><a href="#因特网视频" class="headerlink" title="因特网视频"></a>因特网视频</h4><p>在流式存储视频应用中，基础的媒体时预先录制的视频，这些预先录好的视频房子啊服务器上，用户按需向这些服务去发送请求来观看视频。</p>
<p>视频的一个重要特征是它能够被压缩，因此可用比特率来权衡视频质量， 比特率越高，图像总体视觉感受越好，可以压缩生成视频的多个版本，提供给用户根据当前带宽决定观看哪个版本</p>
<h4 id="HTTP流和DASH"><a href="#HTTP流和DASH" class="headerlink" title="HTTP流和DASH"></a>HTTP流和DASH</h4><p> 在HTTP流中，视频存储在HTTP服务器中作为一个普通的文件，每个文件有一个特定的URL，当用户要看视频的时候，客户与服务器创建一个TCP连接，并发送对该URL的HTTP GET请i去，服务器则以底层网络协议和流量条件允许的尽可能快的速率，在一个HTTP响应报文中发送该视频文件，一旦该缓存中地字节数量超过预先设定地门限，客户应用程序就开始播放。流式视频应用陈虚谷周期性地从客户应用程序缓存中抓取帧，对这些帧解压缩并且在用户屏幕上展现。因此，流式视频应用接收到视频就进行播放，同时缓存该视频后面部分地帧</p>
<p>HTTP流对于不同客户或者在不同地时间地时候，不论客户地可用带宽大小，客户接收到的视频都是相同编码的，就有了新的机遇HTTP流的研发，<strong>HTTP的动态适应流（Dynamic Adaptive Streaming over HTTP， DASH）</strong>视频编码为几个不同的版本，每个版本有不同的比特率，对应于不同的质量水平，每一个版本都有一个不同的URL</p>
<h4 id="内容分发网"><a href="#内容分发网" class="headerlink" title="内容分发网"></a>内容分发网</h4><p>大规模数据中心来提供流式服务的弊端：</p>
<ol>
<li>如果客户远离数据中心，会经过许多ISP，如果这些链路之一提供的吞吐量小于视频小号速率，端到端吞吐量也将小于该消耗速率，产生时延</li>
<li>流行的视频会经过相同的通信链路发送许多次，浪费带宽</li>
<li>如果数据中心通向因特网的链路崩溃将不能够分发任何视频流</li>
</ol>
<p><strong>内容分发网（Content Distribution Network， CDN）</strong> CDN管理分布在多个地理位置上的服务器，并在服务器中存储视频，并且试图将每个用户请求定向到一个将提供最好的用户体验的CDN位置，有<strong>专用CDN</strong>和<strong>第三方CDN</strong></p>
<p>CDN的服务器安置原则：</p>
<ol>
<li><strong>深入</strong>：靠近端用户，通过减少端用户和CDN集群之间链路和路由器的数量，改善用户感受的时延和吞吐量</li>
<li><strong>邀请做客</strong>：通过在少量关键位置制造大集群来邀请到ISP做客，不是将集群放在接入ISP中，可以产生较低的维护和管理开胸啊，会议对端用户的较高时延和较低吞吐量做代价</li>
</ol>
<p><strong>CDN操作</strong>：<br>当用户主机中的一个浏览器指令检索一个特定的视频，CND必须截获该请求，以便能够确定此时适合用于该客户的CDN服务器集群，将客户的请求重定向到该集群的某台服务器</p>
<p><strong>集群选择策略</strong></p>
<p>动态地将客户定向到CDN中地某个服务器集群或数据中心的机制<br>一种简单的策略时指派客户到<strong>地理上最为邻近</strong>的集群，使用商用地理位置数据库，每个LDNS都映射到一个特殊的地理位置，CDN能够对器集群和客户之间的时延和丢包性能执行周期性的实时测量</p>
<h4 id="Netflix，-YouTube和看看"><a href="#Netflix，-YouTube和看看" class="headerlink" title="Netflix， YouTube和看看"></a>Netflix， YouTube和看看</h4><ol>
<li><p>Netflix</p>
<p>Netflix有一个Web网站来处理若干功能，包括用户注册，登录，计费，用于浏览和搜索的电影目录以及一个电影推荐系统，运行于亚马逊云中的亚马逊服务器上，亚马逊云处理下列关键功能：</p>
<ul>
<li>内容摄取</li>
<li>内容处理</li>
<li>向CDN上载版本</li>
</ul>
</li>
<li><p>Youtube</p>
<p>Youtube应用HTTP流，尽量使少量的不同版本为一个视频可用，每个具有不同的比特率和对应的质量等级</p>
<p>Youtube没有应用适应性流（如DASH）需要用户人工选择一个版本</p>
</li>
<li><p>看看</p>
</li>
</ol>
<h3 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h3><p>典型的网络应用是由一对程序组成的，位于两个不同的端系统中，当运行两个程序的时候，创建了一个客户进程和一个服务器进程，同时它们通过从套接字读出和写入数据在彼此之间进行通信，开发者创建一个网络应用时，主要任务就是编写客户程序和服务器程序的代码</p>
<p>网络应用程序有两类，一类有协议标准中所定义的操作实现，另一类网络应用程序是专用的网络应用程序</p>
<p>在研发阶段，开发者必须先决定应用程序时运行在TCP上还是运行在UDP上</p>
<h4 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h4><p>当生成一个套接字的时候，就为它分配一个端口号的标识符，发送进程为分组附上目的地址，该目的地址是由目的主机的IP地址和目的地套接字地端口号组成的</p>
<p>UDP和TCP的套接字编程：</p>
<ol>
<li>客户从其键盘读取一行字符（数据）并将该数据向服务器发送</li>
<li>服务器接收该数据并将这些字符转换为大写</li>
<li>服务器将修改的数据发送给用户</li>
<li>客户接收修改的数据并在其监视器上将该行显示出来</li>
</ol>
<ul>
<li><p>UDPClient.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = <span class="string">&#x27;172.22.172.62&#x27;</span> <span class="comment"># 服务器的IP地址</span></span><br><span class="line">serverport = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)  <span class="comment"># AF_INET指示底层网络使用IPv4,第二个参数时套接字类型,这里意味着时一个UDP套接字,创建套接字的时候,我们没有指定客户套接字的端口号,让操作系统为我们做这件事情</span></span><br><span class="line">message = <span class="built_in">input</span>(<span class="string">&#x27;Input lowercase sentence:&#x27;</span>)</span><br><span class="line">clientSocket.sendto(message.encode(), (serverName, serverport))  <span class="comment"># 将报文由字符串类型转换为字节类型,需要将</span></span><br><span class="line">modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)  <span class="comment">#取缓存长度2048作为输入</span></span><br><span class="line"><span class="built_in">print</span>(modifiedMessage.decode())</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure></li>
<li><p>UDPServer.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"><span class="built_in">print</span>(serverSocket)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, serverPort)) <span class="comment"># 将端口号和套接字绑定在一起,在UDPServer中,代码显示地为该套接字分配一个端口号</span></span><br><span class="line"><span class="built_in">print</span>(serverSocket)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The server is ready to receive&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    a = <span class="built_in">input</span>(<span class="string">&#x27;输入0退出&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> a == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        exit()</span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    <span class="built_in">print</span>(message, clientAddress)</span><br><span class="line">    modifiedMessage = message.decode().upper()</span><br><span class="line">    <span class="built_in">print</span>(modifiedMessage)</span><br><span class="line">    serverSocket.sendto(modifiedMessage.encode(), clientAddress)</span><br></pre></td></tr></table></figure>

<p>UDP不可靠传输，这里实现的功能就是简单的从client传给server，而且client使用一次以后退出，server可以使用多次</p>
</li>
</ul>
<h4 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h4><p>使用TCP，意味着客户和服务器需要在开始互相发送数据之前，通过握手建立TCP连接，随着服务器进程的运行，客户进程能够向服务器发起一个TCP连接，由客户创建一个TCP套接字完成，当客户生成TCP套接字的时候，指定服务器中的欢迎套接字地址，即服务器主机的IP地址和其套接字的端口号，当服务器接收到的时候，会生成一个新的套接字，用于专门的客户，</p>
<ul>
<li><p>TCPClient</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = <span class="string">&#x27;172.22.172.62&#x27;</span></span><br><span class="line">serverport = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM) <span class="comment"># 第二个参数表示是一个TCP套接字,当我们创建的时候仍未指定其端口号,让操作系统来操作</span></span><br><span class="line">clientSocket.connect((serverName, serverport)) <span class="comment"># 这里建立客户端和服务器之间的连接</span></span><br><span class="line">sentence = <span class="built_in">input</span>(<span class="string">&#x27;Input lowercase sentence:&#x27;</span>)</span><br><span class="line">clientSocket.send(sentence.encode()) <span class="comment"># 进入TCP连接发送字符串,并没有显式的船舰一个分组并未该分组附上目的地址,UDP需要这么做</span></span><br><span class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>) <span class="comment"># 等待接收服务器端的字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;From Server: &#x27;</span>, modifiedSentence.decode())</span><br><span class="line">clientSocket.close() <span class="comment"># 关闭TCP连接</span></span><br></pre></td></tr></table></figure></li>
<li><p> TCPServer</p>
</li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, serverPort))</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The server is ready to receive&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    connectionSocket, addr = serverSocket.accept()</span><br><span class="line">    <span class="built_in">print</span>(connectionSocket, addr)</span><br><span class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">    <span class="built_in">print</span>(sentence)</span><br><span class="line">    capitalizedSentence = sentence.upper()</span><br><span class="line">    connectionSocket.send(capitalizedSentence.encode())</span><br><span class="line">    connectionSocket.close()</span><br></pre></td></tr></table></figure>

<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用，计算机网络中最为基础性的问题之一，即两个实体怎样才能在一种会丢失或算坏数据的媒体上可靠地通信。</p>
<h3 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h3><p>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信</strong>，在发送端，运输层将发送应用程序进程接收到地报文转换为运输层<strong>报文段（segment）</strong>,实现的方法将应用报文划分为很小的块,并未每块加上一个运输层首部生成运输层报文段,在发送端系统中,运输层层将这些报文段传递给网络层,网络层将其封装网络层分组并向目的地发送.在接收端,网络层从数据报中提取运输层报文段,并将改报文端向上交给运输层,运输层处理接收到的报文端,使改报文端中的数据为接收应用进程使用</p>
<h4 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h4><p>在协议栈中,运输层位于网络层之上,网络层提供了主机之间的逻辑通信,而运输层为运行子不同主机上的进程之间提供了逻辑通信.即使底层网络协议不能在网络层提供相应的服务,运输层协议也可以提供某些服务.例如:即使底层网络协议使不可靠的,也就是说网络协议会使分组丢失,篡改和冗余,运输协议也能为应用程序提供可靠的数据传输服务;即使让网络层不能保证运输层报文段的机密性,运输协议也能使用加密来确保应用程序报文不被入侵者读取</p>
<h4 id="因特网运输层概述"><a href="#因特网运输层概述" class="headerlink" title="因特网运输层概述"></a>因特网运输层概述</h4><p>因特网为应用层提供了两种截然不同的可用运输协议,一个是UDP(用户数据报协议),为调用它的应用程序提供了一种不可靠,无连接的服务.另一种是TCP,为调用它的应用程序提供了一种可靠的,面向连接的服务.</p>
<p>首先简单介绍一下因特网的网络层:因特网网络层协议叫(IP)即网络协议,IP为主机之间提供了逻辑通信,IP的服务模型是<strong>尽力而为交付服务</strong>,IP不确保报文段的交付,以及报文段的按序交付,也不保证报文段中数据的完整性,因此IP被称为<strong>不可靠服务</strong></p>
<p>UDP和TCP的最基本的责任是:将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务.将主机间交付扩展到进程间交付被称为<strong>运输层的多路复用</strong>与<strong>多路分解</strong>,UDP和TCP还可以通过在报文段首部中包括差错检查字段而提供完整性检查</p>
<p>UDP与IP一样也是不可靠传输,不能保证一个进程所发送的数据能够完整无缺地到达目的进程</p>
<p>TCP为应用程序提供了几种附加的服务，提供<strong>可靠数据传输</strong>，通过使用流量控制，序号，确认和定时器，确保正确的按序地将数据从发送进程交付给接收进程。还提供拥塞控制，防止任何一条TCP连接用过多流量来淹没通信主机之间地链路和交换设备。</p>
<h3 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><p>一个进程有一个或多个套接字，相当于从网络向进程传递数据和从进程向网络传递数据的门户。</p>
<p>为了将一个到达的运输层报文段定向到一个适当的套接字，每个运输层报文段都有几个字段，在接收端，运输层检查这些子杜纳，教师出接收套接字，然后将报文段定向到改套接字，将报文段中的数据交付到正确的套接字的工作称为<strong>多路分解</strong>，在源主机从不同套接字中收集数据块并为每个数据块分装上首部信息，从而生成报文段，然后将报文段传递到网络层，所有这些工作称为<strong>多路复用</strong></p>
<p>运输层多路复用要求</p>
<ol>
<li>套接字有唯一标识符</li>
<li>每个报文段有特殊字段来指示该报文段所要交付到的套接字<ol>
<li><strong>源端口号字段(source port number field)</strong></li>
<li><strong>目的端口号字段(destination port number field)</strong><ul>
<li>周知端口号:0~1023范围的端口号</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="无连接的多路复用和多路分解"><a href="#无连接的多路复用和多路分解" class="headerlink" title="无连接的多路复用和多路分解"></a>无连接的多路复用和多路分解</h4><p><code>clientSocket = socket(AF_INET, SOCK_DGRAM)</code>这样创建UDP套接字时,运输层会自动为该套接字分配一个端口号,从范围1023到65535中分配,我们也可以通过<code>clientSocket.bind((&#39;&#39;, 19597))</code>来关联一个特定的端口号</p>
<p>一个UDP套接字是由一个二元组全面标识的, 该二元组包含一个目的IP地址和一个目的端口号</p>
<p>源端口号用来当作返回地址的一部分</p>
<h4 id="面向连接的多路复用和多路分解"><a href="#面向连接的多路复用和多路分解" class="headerlink" title="面向连接的多路复用和多路分解"></a>面向连接的多路复用和多路分解</h4><p>TCP套接字是一个四元组,<code>(源IP地址, 源端口号, 目的IP地址, 目的端口号)</code>来标识的,服务器主机可以支持很多并行的TCP套接字,每个套接字与一个进程相联系,并由其四元组来标识每个套接字,</p>
<h4 id="Web服务器与TCP"><a href="#Web服务器与TCP" class="headerlink" title="Web服务器与TCP"></a>Web服务器与TCP</h4><p>每一个进程都有自己的套接字，但是套接字与进程之间并非总是又一一对应的关系，当下的Web服务器通常只是用一个进程但是为每个新的客户连接创建一个具有新连接套接字的新线程</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>有很多应用适合用UDP，因为：</p>
<ul>
<li>关于发送什么数据以及何时发送的应用控制更为精细，TCP有拥塞控制机制，一边当源和目的主机间的一条或多条链路变得极度拥塞的时候来遏制运输层TCP发送方</li>
<li>无需建立连接，eg：DNS运行在UDP上，不需要每次都三次握手建立连接，比TCP快很多</li>
<li>无连接状态：TCP需要在端系统中维持连接状态，包括接收和发送缓存，拥塞控制参数以及序号与确认号的参数</li>
<li>分组开销小。TCP需要20字节的首部，UDP需要8字节的首部</li>
</ul>
<p>UDP运行在多媒体应用是由争议的。我们需要拥塞控制来预防网络进入一种拥塞状态，如果每个人都启用流式高比特率视频而不适用任何拥塞控制的话，会是路由器由大量分组的溢出，以至于很少的UDP分组能够成功从源到目的地</p>
<h4 id="UDP报文结构"><a href="#UDP报文结构" class="headerlink" title="UDP报文结构"></a>UDP报文结构</h4><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211103225041616.png" alt="image-20211103225041616"></p>
<p>UDP首部只有4个字段，每个字段2字节。</p>
<ul>
<li>通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程</li>
<li>长度字段指示了在UDP报文中的字节数（首部加数据），因为数据字段的长度在一个UDP段中不同于在另一个UDP段中</li>
<li>接收方用校验和来检查在报文中是否有差错</li>
</ul>
<h4 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h4><p>UDP校验和提供差错校验功能，发送方的UDP对报文段中的所有16比特字的和，如果有任何溢出都被回卷（溢出的长度加到16比特字一起）然后取反码放到校验和的位置，如果接收方，所有16比特字的和加上校验和不为1111111111111111，则在分组中出现差错</p>
<blockquote>
<p>端到端原则: 在于较高级别提供这些功能的代价相比, 在较低级别上设置的功能可能使冗余的或几乎没有价值的. </p>
</blockquote>
<h3 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h3><p><strong>可靠数据传输(reliable data transfer protocol)</strong></p>
<h4 id="构建可靠数据传输协议"><a href="#构建可靠数据传输协议" class="headerlink" title="构建可靠数据传输协议"></a>构建可靠数据传输协议</h4><ol>
<li><p>经完全可靠信道的可靠数据传输: rdt1.0</p>
<p>底层信道完全可靠(无错序,丢包,比特突变)</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/24/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-0x2/" rel="prev" title="刷题记录-0x2">
      <i class="fa fa-chevron-left"></i> 刷题记录-0x2
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/20/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-0x3/" rel="next" title="刷题记录-0x3">
      刷题记录-0x3 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MzE3MS8yOTY0Nw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91"><span class="nav-number">1.</span> <span class="nav-text">计算机网络和因特网</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%A0%E7%89%B9%E7%BD%91"><span class="nav-number">1.1.</span> <span class="nav-text">什么是因特网</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%9E%84%E6%88%90%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">具体构成描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">服务描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.1.3.</span> <span class="nav-text">什么是协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%BE%B9%E7%BC%98"><span class="nav-number">1.2.</span> <span class="nav-text">网络边缘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%85%A5%E7%BD%91"><span class="nav-number">1.2.1.</span> <span class="nav-text">接入网</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%AA%92%E4%BD%93"><span class="nav-number">1.2.2.</span> <span class="nav-text">物理媒体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83"><span class="nav-number">1.3.</span> <span class="nav-text">网络核心</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.3.1.</span> <span class="nav-text">分组交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.3.2.</span> <span class="nav-text">电路交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="nav-number">1.3.3.</span> <span class="nav-text">网络的网络</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6-%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">1.4.</span> <span class="nav-text">分组交换网中的时延,丢包和吞吐量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E4%B8%AD%E6%97%B6%E5%BB%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">1.4.1.</span> <span class="nav-text">分组交换网中时延概述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6%E5%92%8C%E4%B8%A2%E5%8C%85"><span class="nav-number">1.5.</span> <span class="nav-text">排队时延和丢包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%97%B6%E5%BB%B6"><span class="nav-number">1.5.1.</span> <span class="nav-text">端到端时延</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">计算机网络中的吞吐量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1%E5%8F%8A%E5%99%A8%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.6.</span> <span class="nav-text">协议层次及器服务模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.1.</span> <span class="nav-text">分层的体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">1.6.2.</span> <span class="nav-text">封装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E6%94%BB%E5%87%BB%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="nav-number">1.7.</span> <span class="nav-text">面向攻击的网络</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">应用层协议原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.1.</span> <span class="nav-text">网络应用程序体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">2.1.2.</span> <span class="nav-text">进程通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E4%BE%9B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%90%E8%BE%93%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.1.3.</span> <span class="nav-text">可供应用程序使用的运输服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E6%8F%90%E4%BE%9B%E7%9A%84%E8%BF%90%E8%BE%93%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.1.4.</span> <span class="nav-text">因特网提供的运输服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.5.</span> <span class="nav-text">应用层协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E6%B6%89%E5%8F%8A%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8"><span class="nav-number">2.1.6.</span> <span class="nav-text">本章涉及的网络应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#web%E5%92%8CHTTP"><span class="nav-number">2.2.</span> <span class="nav-text">web和HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#http%E6%A6%82%E5%86%B5"><span class="nav-number">2.2.1.</span> <span class="nav-text">http概况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%8C%81%E7%BB%AD%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%8C%81%E7%BB%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.2.2.</span> <span class="nav-text">非持续连接和持续连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.2.3.</span> <span class="nav-text">HTTP报文格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92-cookie"><span class="nav-number">2.2.4.</span> <span class="nav-text">用户与服务器的交互:cookie</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web%E7%BC%93%E5%AD%98"><span class="nav-number">2.2.5.</span> <span class="nav-text">Web缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6GET%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.6.</span> <span class="nav-text">条件GET方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E4%B8%AD%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="nav-number">2.3.</span> <span class="nav-text">因特网中的电子邮件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SMTP"><span class="nav-number">2.3.1.</span> <span class="nav-text">SMTP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8EHTTP%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">2.3.2.</span> <span class="nav-text">与HTTP的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%AE%E4%BB%B6%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.3.3.</span> <span class="nav-text">邮件报文格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%AE%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.3.4.</span> <span class="nav-text">邮件访问协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS-%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%9B%AE%E5%BD%95%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.4.</span> <span class="nav-text">DNS:因特网的目录服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.4.1.</span> <span class="nav-text">DNS提供的服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS%E5%B7%A5%E4%BD%9C%E6%9C%BA%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-number">2.4.2.</span> <span class="nav-text">DNS工作机理概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS%E8%AE%B0%E5%BD%95%E5%92%8C%E6%8A%A5%E6%96%87"><span class="nav-number">2.4.3.</span> <span class="nav-text">DNS记录和报文</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P2P%E6%96%87%E4%BB%B6%E5%88%86%E5%8F%91"><span class="nav-number">2.5.</span> <span class="nav-text">P2P文件分发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E6%B5%81%E5%92%8C%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91"><span class="nav-number">2.6.</span> <span class="nav-text">视频流和内容分发网</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E8%A7%86%E9%A2%91"><span class="nav-number">2.6.1.</span> <span class="nav-text">因特网视频</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E6%B5%81%E5%92%8CDASH"><span class="nav-number">2.6.2.</span> <span class="nav-text">HTTP流和DASH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91"><span class="nav-number">2.6.3.</span> <span class="nav-text">内容分发网</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netflix%EF%BC%8C-YouTube%E5%92%8C%E7%9C%8B%E7%9C%8B"><span class="nav-number">2.6.4.</span> <span class="nav-text">Netflix， YouTube和看看</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="nav-number">2.7.</span> <span class="nav-text">套接字编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="nav-number">2.7.1.</span> <span class="nav-text">UDP套接字编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="nav-number">2.7.2.</span> <span class="nav-text">TCP套接字编程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0%E5%92%8C%E8%BF%90%E8%BE%93%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.1.</span> <span class="nav-text">概述和运输层服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.1.1.</span> <span class="nav-text">运输层和网络层的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.2.</span> <span class="nav-text">因特网运输层概述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3"><span class="nav-number">3.2.</span> <span class="nav-text">多路复用与多路分解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3"><span class="nav-number">3.2.1.</span> <span class="nav-text">无连接的多路复用和多路分解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3"><span class="nav-number">3.2.2.</span> <span class="nav-text">面向连接的多路复用和多路分解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8ETCP"><span class="nav-number">3.2.3.</span> <span class="nav-text">Web服务器与TCP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP"><span class="nav-number">3.3.</span> <span class="nav-text">UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.1.</span> <span class="nav-text">UDP报文结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="nav-number">3.3.2.</span> <span class="nav-text">UDP校验和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86"><span class="nav-number">3.4.</span> <span class="nav-text">可靠数据传输原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.4.1.</span> <span class="nav-text">构建可靠数据传输协议</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="STEVE"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">STEVE</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Mon Apr 05 2021 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">STEVE</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
